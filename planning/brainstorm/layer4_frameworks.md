# Layer 4: Extended Frameworks

> Navigation: [Session Overview](./00-session-overview.md) · [Layer 1: 8 DNAs](./layer1_dna.md) · [Layer 2: Evolution Flow](./layer2_dna.md) · [Layer 3: Builder's Lenses](./layer3_dna.md) · [Layer 4 (This): Extended Frameworks] · [20-Chapter Mapping](./20-chapter-structure-mapping.md)

**Templates:** [Hierarchy](./templates/layer4/hierarchy/README.md) · [Cognitive Load](./templates/layer4/cognitive-load/README.md) · [Product Gravity](./templates/layer4/product-gravity/README.md) · [Bio-Agile](./templates/layer4/bio-agile/README.md) · [NCO](./templates/layer4/nco/README.md) · [APAP](./templates/apap/)

**Purpose:** Layer 4 adds specialized amplification frameworks that sit atop the foundational genome (Layer 1), operational cadence (Layer 2), and interpretive lenses (Layer 3). These frameworks deepen diagnostic power, execution discipline, and adaptive intelligence. They are optional accelerators—adopt progressively as maturity rises.

**Included Frameworks:**
1. Builder's Hierarchy
2. Cognitive Load Engineering
3. Product Gravity
4. Bio-Agile Adaptation
5. Neural Co-Creation Orchestrator (NCO) *(renamed from working codename "Blueberry" to reflect AI-assisted iterative collaboration as an orchestrated process rather than a whimsical label)*
6. AI-Assisted Product Assembly Pipeline (APAP) *(transactional build pipeline derived from NCO; multi-stage orchestration from prompt → publish)*

---
## 1. Builder's Hierarchy
**Definition:** A structural stack explaining how abstract intent materializes into measurable value. Each lower layer instantiates commitments from the layer above; misalignment detection occurs by tracing upward.

**Hierarchy Levels (Top → Bottom):**
1. Purpose Intent (WHY outcome space)
2. Outcome Map (Measurable success states)
3. System Capability Model (Enduring capacities enabling outcomes)
4. Product Domains / Services (Organized structural components)
5. Feature Sets (Mutable expressions of capability)
6. Interaction Patterns (UX flows & semantic behaviors)
7. Implementation Artifacts (Code, infra configs, pipelines)
8. Instrumentation & Telemetry (Observation & feedback closure)

**Core Questions:**
- Does each feature map to an explicit capability and outcome? (Traceability)
- Is capability drift occurring (feature bloat without outcome uplift)?
- Are domains reinforcing or fragmenting capability cohesion?
- Is telemetry proving outcome realization or just measuring surface activity?

**Artifacts:**
- Hierarchy Trace Matrix (Feature → Capability → Outcome → Purpose)
- Capability Health Dashboard (fitness score per capability)
- Drift Report (items with weak upward linkage)
- Outcome Validation Map (telemetry metric → outcome claim)

**Operating Principles:**
- Upward Justification: Nothing exists without referencing a higher layer claim.
- Downward Sufficiency: Higher layer must have at least one concrete instantiation below.
- Periodic Drift Audits: Monthly trace to prune misaligned artifacts.

**Anti-Patterns:**
- "Feature-first" backlog lacking capability/outcome context.
- Telemetry focused on usage counts instead of outcome attainment.
- Creating new domains due to local optimization desires vs systemic capacity needs.

**Quick Checklist:**
- [ ] All features mapped to outcomes
- [ ] No orphan capabilities
- [ ] Telemetry validates outcomes, not vanity
- [ ] Drift items queued for correction

**Integration:** Links Purpose & User DNAs (why) to Experience & Architecture DNAs (how) via explicit capability scaffolding; used during Decomposition & Design stages (Layer 2), filtered through Systems & Architectural lenses (Layer 3).

---
## 2. Cognitive Load Engineering
**Definition:** A disciplined approach to budgeting and refactoring cognitive load for both users and builders. It treats complexity as a constrained resource: perceived complexity (user) & structural complexity (team).

**Load Dimensions:**
- Intrinsic (irreducible domain complexity)
- Extraneous (avoidable friction / noise)
- Germane (productive mental effort enabling mastery)

**Core Questions:**
- Where does user flow stall due to context switching or ambiguity?
- What complexity is accidental (naming inconsistency, fragmented navigation)?
- Are internal abstractions increasing builder comprehension or obscuring intent?
- What is the cognitive budget per critical flow (time-to-schema formation)?

**Artifacts:**
- Cognitive Load Audit (per flow & per module)
- Complexity Budget Charter (thresholds for flows & code surfaces)
- Semantic Layer Map (conceptual entities ↔ surface vocabulary)
- Refactor Opportunity Ledger (extraneous complexity removal ranked by impact)
- Naming Consistency Registry (canonical term dictionary)

**Operating Principles:**
- Budget Before Build: Define acceptable load targets prior to design.
- Remove Extraneous First: Do not optimize intrinsic until noise is pruned.
- Semantic Consistency Is a Release Gate for key flows.
- High-germane load allowed only when it compounds future capability (e.g., advanced setup wizard for power users).

**Anti-Patterns:**
- Complexity inversion: heavy extraneous noise tolerated while optimizing trivial intrinsic complexity.
- Abstraction inflation: new layers added to "simplify" but increase mental hops.
- Jargon drift: vocabulary inconsistency across UI, docs, and code.

**Quick Checklist:**
- [ ] Flows mapped with load classification
- [ ] Budgets set & monitored
- [ ] Extraneous hotspots queued for removal
- [ ] Semantic dictionary enforced
- [ ] Builder abstraction review scheduled

**Integration:** Tight synergy with Psychological Lens (Layer 3) & Experience DNA. Applied during Design & Validate stages; influences Golden Path shaping & MQB thresholds.

---
## 3. Product Gravity
**Definition:** Explains the accumulating "pull" that retains users and attracts adjacent ecosystems. Gravity emerges from compounding alignment of value, trust, habitual integration, and ecosystem interdependence.

**Gravity Components ("Mass Contributors"):**
- Sustained Outcome Delivery (consistent JTBD success)
- Trust Signals (uptime, correctness, ethical data stewardship)
- Habit Formation (embedded daily/weekly rhythms)
- Integration Web (APIs, plugins, workflow continuity)
- Ecosystem Narrative (identity coherence & differentiation)

**Core Questions:**
- Which components are underweighted (low mass)?
- Are we leaking gravitational pull via reliability or narrative inconsistency?
- What integrations amplify retention loops most efficiently?
- How does experimentation affect mass trajectory (net positive or fragmentation)?

**Artifacts:**
- Gravity Scorecard (component scores & trend lines)
- Integration Leverage Map (integration → retention uplift index)
- Narrative Consistency Index (content & experience alignment checks)
- Habit Loop Inventory (trigger → action → reward → reinforcement)
- Trust Ledger (negative & positive trust events tracked)

**Operating Principles:**
- Reinforce Core Mass Before Extending Periphery.
- Quantify retention impacts of integration initiatives pre-build.
- Protect trust mass: triage reliability regressions ahead of new growth experiments.
- Narrative is structural: treat it as an integrity dimension, not marketing garnish.

**Anti-Patterns:**
- Feature scatter diluting narrative cohesion.
- Integration sprawl without prioritization by retention leverage.
- Growth hacks that spike acquisition but erode trust / experience quality.

**Quick Checklist:**
- [ ] Gravity components scored & monitored
- [ ] Top leverage integrations prioritized
- [ ] Trust events instrumented & reviewed
- [ ] Habit loops refined (friction & reward balance)
- [ ] Narrative consistency audit passed

**Integration:** Leverages Growth, Experience, Cultural DNAs; Systems lens models gravitational loops; Constraint lens ensures scalability under increased load.

---
## 4. Bio-Agile Adaptation
**Definition:** A biologically inspired adaptive framework treating the product ecosystem like a living organism: metabolic efficiency, immune defense (error & failure handling), regenerative capacity (refactor & recovery), growth morphology (scaling patterns), and ecological symbiosis (integrations/market fit).

**Bio-Agile Dimensions:**
- Metabolism (resource conversion efficiency: compute, team effort → value)
- Immune System (detection & neutralization of defects/anomalies)
- Regeneration (refactors, debt paydown, dependency updates)
- Growth Morphology (scaling form changes: horizontal, functional, modular)
- Symbiosis (external services/platform synergy & mutual reinforcement)

**Core Questions:**
- Is metabolic overhead rising faster than delivered outcome value?
- How quickly do we detect and isolate functional regressions?
- Are regeneration cycles frequent & effective (debt half-life tracked)?
- Does scaling introduce pathological complexity forms?
- Which external symbioses create mutual compounding value vs parasitic drag?

**Artifacts:**
- Metabolic Efficiency Dashboard (value units / cost units ratio trends)
- Immune Response Timeline (defect detection → containment → resolution durations)
- Regeneration Calendar (scheduled refactor/upgrade cadences & completion rate)
- Complexity Morphology Map (structure evolution snapshots over time)
- Symbiosis Portfolio (integration classification: mutual / neutral / parasitic)

**Operating Principles:**
- Maintain Healthy Metabolic Ratio: intervene when efficiency declines by threshold.
- Immunity Is Layered: proactive (tests), reactive (monitoring), adaptive (post-mortems → pattern updates).
- Regeneration Is Scheduled, Not Opportunistic.
- Morphology Reviews Precede Major Scaling Initiatives.
- Symbiosis Evaluation Includes Cultural & Trust Impact.

**Anti-Patterns:**
- Chronic underinvestment in regeneration (compounding debt toxicity).
- Immune monoculture (reliance on one detection method).
- Unexamined exponential scaling complexity.
- Symbiotic dependency becoming single point of strategic failure.

**Quick Checklist:**
- [ ] Efficiency ratio within target band
- [ ] Mean detection & resolution times acceptable
- [ ] Debt half-life decreasing
- [ ] Structural morphology stable or intentionally directed
- [ ] Symbiosis classifications updated quarterly

**Integration:** Fuses Architecture, Data, Validation DNAs with Evolution lens insights; informs Build & Evolve stages (Layer 2) by shaping maintenance vs growth investment balance.

---
## 5. Neural Co-Creation Orchestrator (NCO)
**Definition:** A structured human–AI collaboration and iteration loop that transforms raw intent into validated product increments with minimal drift and maximal learning capture. Moves beyond ad-hoc AI usage toward governed co-creation.

**Stages (Orchestrated Loop):**
1. Intent Framing (human) – Outcome, constraints, user context scoped
2. Context Injection (human) – Provide genome-aligned artifacts (Purpose, JTBD, MQB)
3. Draft Generation (AI) – Produce structured proposals (design spec, code scaffold, test outline)
4. Human Critical Review (human) – Systems & Psychological lenses applied for coherence
5. Constraint & Architecture Guarding (automated + human) – Static checks vs contracts, latency budgets
6. Refinement Pass (AI) – Incorporates review deltas, strengthens traceability tags
7. Validation Harness Execution (automated) – Tests, lint, semantic diff, complexity thresholds
8. Learning Capture (AI assist) – Summarize deltas, decisions, risk notes → ADR & Validation Log
9. Integration & Telemetry Tagging (human + scripted) – Instrument new surfaces

**Core Questions:**

**Artifacts:**

**Operating Principles:**

**Anti-Patterns:**

**Quick Checklist:**

**Integration:** Amplifies Design & Build stages (Layer 2), requires Architecture, Experience & Validation DNA artifacts for grounding; monitored via Systems & Constraint lenses for ROI and risk.

**Why Rename from "Blueberry":** A whimsical codename obscures function & governance intent. "Neural Co-Creation Orchestrator" communicates collaborative AI process, sequencing, and structured oversight—reinforcing seriousness, auditability, and alignment to the genome.

## 6. AI-Assisted Product Assembly Pipeline (APAP)
**Definition:** A transactional, end-to-end pipeline that turns a master vision prompt into a working product through seven governed stages. It complements NCO by focusing on assembly flow and integration checkpoints, blending AI generation with human drag/drop and template reuse to optimize cost, speed, and quality.

**Stage Overview (Governed Flow):**
1. **Vision Prompt & Decomposition**
	- Input: Master prompt describing product vision and constraints
	- Action: AI decomposes into three scoped prompts: Frontend, Database, Process/Automation (backend)
	- Options: Start with master vision or begin at a specific level (e.g., Frontend first)
	- Outputs: Prompt set + traceability tags back to Purpose/Outcome; guardrail checks ensure genome alignment

2. **Frontend Assembly & Design Realization**
	- Modes: AI-generated UI code/specs or human-assisted drag/drop using prebuilt components/templates to conserve AI credits
	- Guidance: Psychological lens ensures mental model alignment; Experience DNA MQB gates enforce clarity, latency, accessibility
	- Outputs: Frontend component library + golden path flows; instrumentation stubs

3. **Database Modeling & Data Surface Definition**
	- Modes: AI proposes schema in tabular/“sheet-like” views editable by humans; supports manual table creation
	- Intelligence: Cross-checks with frontend artifacts to detect missing entities/fields; Data DNA ensures intentional capture
	- Outputs: Schema, migrations, seed data scaffolds; privacy/compliance register entries

4. **Process & Automation Orchestration**
	- Modes: Drag/drop process builder or AI-synthesized workflows; supports human adjustments
	- Constraints: Architectural & Constraint lenses enforce boundary integrity, budgets, and latency/throughput targets
	- Outputs: Workflow definitions, jobs, triggers; interface contracts for services/APIs

5. **Third-Party Integration Templates**
	- Inputs: API keys and provider selection
	- Action: APAP enumerates available data streams and suggests default connection templates derived from vision prompt; human can modify or request AI refinements
	- Outputs: Integration specs, security scopes, rate-limit plans; trust signal instrumentation

6. **Assembly & System Integration**
	- Action: Tie front-end, schema, automations, and integrations; ensure contracts match; run static checks
	- Guardrails: Architectural lens for boundary adherence; Systems lens for loop integrity; Evolution lens for reversible flags
	- Outputs: Integrated app with env configs; deployment manifests; telemetry wired

7. **Quality Assurance & Publish**
	- QA: Validation DNA drives tests (unit/integration/e2e); MQB gates; human accept/reject with evidence
	- Publish: Staged rollout, canary, or direct release; post-release monitoring hooks
	- Outputs: Gate report, release notes, production publish, rollback plan

**Core Questions:**
- Does each stage preserve traceability to Purpose, Outcomes, and Capability models?
- Are MQB and constraint budgets enforced before progression?
- Is human-in-the-loop engagement cost-effective (AI vs template/drag-drop balance)?
- Do integrations strengthen Product Gravity without eroding trust?

**Artifacts:**
- Prompt Decomposition Map (vision → FE/DB/Process)
- Frontend Golden Path Spec + Component Catalog
- Schema Sheet + Migration Plan + Compliance Register entries
- Process Builder Diagram + Interface Contracts
- Integration Template Catalog + Security/Rate-Limit Plans
- Assembly Check Log (contracts, telemetry, flags)
- QA Gate Report + Release Manifest

**Operating Principles:**
- Start with Context: Always feed genome artifacts into APAP (Purpose, JTBD, MQB)
- Cost-Aware Assembly: Prefer templates/components when suitable; reserve AI credits for complex synthesis
- Guardrail-First: Advance only when gates (MQB, constraints, contracts) pass
- Iterative Publish: Favor staged rollouts with telemetry and rollback readiness

**Anti-Patterns:**
- Vision-less generation (prompt without Purpose/User/Experience context)
- Skipping MQB/constraint gates to “save time”
- Integrations added without gravity/trust assessment
- One-shot publish without canary/monitoring

**Quick Checklist:**
- [ ] Vision prompt decomposed with trace tags
- [ ] Frontend meets MQB & mental model alignment
- [ ] Schema validated vs frontend & compliance
- [ ] Processes modeled with contracts & budgets
- [ ] Integrations templated & secured
- [ ] Assembly checks passed; telemetry wired
- [ ] QA gate PASS/CONCERNS addressed; publish plan ready

**Integration:** APAP is the transactional counterpart to NCO: NCO governs co-creation quality and learning capture; APAP governs assembly sequencing and gates. Both consume Layer 1 DNAs, operate within Layer 2 stages, and are scrutinized by Layer 3 lenses.

| Framework | Primary Reinforced DNAs | Key Lens Alignment | Primary Stage Injection |
|-----------|-------------------------|--------------------|-------------------------|
| Builder's Hierarchy | Purpose, Growth, Architecture | Architectural, Systems | Vision, Decomposition |
| Cognitive Load Engineering | Experience, User | Psychological, Constraint | Design, Validate |
| Product Gravity | Growth, Cultural, Experience | Systems, Psychological | Evolve, Vision |
| Bio-Agile Adaptation | Architecture, Validation, Data | Evolution, Systems | Build, Evolve |
| NCO | Architecture, Experience, Validation | Architectural, Psychological, Constraint | Design, Build |
| APAP | Experience, Data, Validation, Architecture | Psychological, Architectural, Constraint, Systems | Build, Validate, Evolve |

---
## Adoption Sequence Guidance
1. Builder's Hierarchy (traceability foundation)
2. Cognitive Load Engineering (user & team clarity uplift)
3. Product Gravity (retention & ecosystem leverage)
4. Bio-Agile (health & resilience scaling)
5. NCO (accelerated, governed AI augmentation)

Adopt sequentially; each earlier framework increases ROI & safety of later ones.

---
## Implementation Launch Checklist
- [ ] Select initial framework (Hierarchy) & build trace matrix
- [ ] Run first cognitive load audit on top JTBD golden path
- [ ] Establish gravity score baseline & trust ledger
- [ ] Define metabolic & immune metrics (Bio-Agile) & schedule first review
- [ ] Pilot a single NCO co-creation session with full logging
- [ ] Integrate framework artifacts into story / ADR templates

---
## Integration With Earlier Layers
- **Layer 1:** Frameworks consume DNAs as structured inputs (e.g., Hierarchy uses Purpose outcomes; Cognitive Load uses Experience MQB; NCO requires Architecture & Validation artifacts).
- **Layer 2:** Inject checkpoints (e.g., Decomposition includes capability mapping; Design includes cognitive budget review; Build includes Bio-Agile metabolic metrics collection).
- **Layer 3:** Lenses direct audit emphasis (Systems for Hierarchy drift, Psychological for load, Architectural for NCO guardrails, Evolution for Bio-Agile morphologies, Constraint for gravity vs scalability trade-offs).

---
## Measuring Framework Value (Meta-Metrics)
| Dimension | Indicator | Baseline Goal |
|-----------|----------|---------------|
| Traceability | % features with full upward chain | >90% |
| Cognitive Simplicity | Mean flow comprehension time | ↓ 30% from baseline |
| Gravity | Composite gravity score (0–100) | +15 in 2 quarters |
| Bio-Agile Health | Defect detection MTTR / Debt half-life | MTTR < 2h / Debt half-life < 3 months |
| NCO Efficiency | Net development time saved vs corrections | ≥25% net gain |

---
## Anti-Fragility Amplification
Convergent adoption of frameworks reduces systemic blind spots: traceability curbs misaligned expansion, load engineering protects usability, gravity sustains retention, bio-agile prevents decay, NCO accelerates safe throughput. Monitor for framework fatigue—over-instrumentation can itself become extraneous load.

---
## Future Extension Hooks
- Builder's Hierarchy → Capability Fitness ML predictions
- Cognitive Load → Real-time adaptive UI simplification engine
- Product Gravity → Predictive churn gravity delta alerts
- Bio-Agile → Automated regeneration scheduling via entropy heuristics
- NCO → Self-tuning prompt optimizer using drift analytics

---
*End of Layer 4 Documentation – Extended Frameworks*
